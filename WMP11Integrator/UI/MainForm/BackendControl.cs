using System;
using System.Text;
using System.Collections.Generic;
using System.IO;
using Epsilon.IO;
using Epsilon.DebugServices;
using System.Windows.Forms;
using System.Threading;

namespace Epsilon.Slipstreamers.WMP11Slipstreamer
{
    partial class MainForm
    {
        Backend _backend;
        bool _workerInCriticalOperation;

        void WorkerMethod(object workerParam)
        {
            BackendParams paramsBackend = (BackendParams)workerParam;

            try
            {
                this._backend = new Backend(paramsBackend);

                // Handle the events generated by the backend
                this._backend.AnnounceOperation
                    += new Action<string>(_backend_OnAnnounceOperation);
                this._backend.Message
                    += new EventHandler<Backend.MessageEventArgs>(
                    this._backendInstance_OnMessage);
                this._backend.CurrentProgressUpdate
                    += new Backend.ProgressEventDelegate(
                    this._backend_OnCurrentProgressUpdate);
                this._backend.GlobalProgressUpdate
                    += new Backend.ProgressEventDelegate(
                    this._backend_OnGlobalProgressUpdate);
                this._backend.EnterCriticalOperation
                    += new Backend.CriticalOperationEventDelegate(
                    delegate() { this._workerInCriticalOperation = true; });
                this._backend.ExitCriticalOperation
                    += new Backend.CriticalOperationEventDelegate(
                    delegate() { this._workerInCriticalOperation = false; });

#if DEBUG
                // Helps in debugging
                this._backend.OnBeforeMergeFolders
                    += new Backend.DebuggingYesNoQuestionDelegate(
                    this._backendInstance_OnBeforeMergeFolders);
                this._backend.OnDebuggingMessage
                    += new Backend.DebuggingMessageDelegate(
                    this._backendInstance_OnDebuggingMessage);
#endif

                // Start the backend's operations
                this._backend.Slipstream();

                // If it made it up to here with no exceptions, then it succeeded.
                paramsBackend.Result = BackendResult.Success;
            }
            catch (Backend.Exceptions.SlipstreamerAbortedException)
            {
                try
                {
                    FileSystem.Delete(this._backend.WorkingDirectory);
                }
                catch (Exception unexpected)
                {
                    this.CrossThreadMessageBox(
                        "An error occurred while deleting the temporary folder."
                        + Environment.NewLine
                        + "Please delete the following folder manually"
                        + " to restore your source to its previous condition:"
                        + Environment.NewLine + Environment.NewLine
                        + this._backend.WorkingDirectory
                        + Environment.NewLine + Environment.NewLine
                        + "Error details: " + unexpected.Message, 
                        "Error while cancelling", MessageBoxIcon.Error);
                }
                finally
                {
                    paramsBackend.Result = BackendResult.Cancelled;
                }
            }
            catch (Backend.Exceptions.IntegrationException ex)
            {
                HelperConsole.ErrorWriteLine("Integration Error:");
                HelperConsole.ErrorWriteLine(ex.ToString());

                if (ex.InnerException != null)
                {
                    this.ShowUnhandledExceptionForm(paramsBackend, ex.InnerException);
                }
                else
                {
                    this.CrossThreadMessageBox("An error occurred during integration:"
                        + Environment.NewLine
                        + Environment.NewLine
                        + ex.FullMessage,
                        "Integration Error", MessageBoxIcon.Error
                    );

                    paramsBackend.Result = BackendResult.Error;

                }
            }
            catch (Exception ex)
            {
                HelperConsole.ErrorWriteLine("Unhandled Error:");
                HelperConsole.ErrorWriteLine(ex.ToString());

                ShowUnhandledExceptionForm(paramsBackend, ex);
            }
            finally
            {
                // Return to first state
                this.CrossThreadControlVisibility(this.uxProgressBarCurrent, false);
                this.CrossThreadProgressUpdate(this.uxProgressBarOverall, 0, 1);
                this.CrossThreadControlEnabled(this.uxButtonCancel, true);
                this.CrossThreadControlText(this.uxLabelOperation, String.Empty);
            }
        }

        private void ShowUnhandledExceptionForm(BackendParams paramsBackend, Exception ex)
        {
            try
            {
                this.CrossThreadShowDialog(new ErrorForm(ex,
                    this._workerInCriticalOperation,
                    this._backend.WorkingDirectory,
                    this._backend.OsInfo.ToString(),
                    this.uxTextBoxHotfixLine.Text));
            }
            finally
            {
                paramsBackend.Result = BackendResult.UnhandledException;
            }
        }

        #region Backend event handlers
        void _backend_OnAnnounceOperation(string announceString)
        {
            this.CrossThreadControlText(this.uxLabelOperation, announceString);
        }

        void _backend_OnCurrentProgressUpdate(int val, int max)
        {
            this.CrossThreadProgressBarHandler(this.uxProgressBarCurrent, val, max);
        }

        void _backend_OnGlobalProgressUpdate(int val, int max)
        {
            this.CrossThreadProgressBarHandler(this.uxProgressBarOverall, val, max);
        }

        void CrossThreadProgressBarHandler(ProgressBar progressBar, int val, int max)
        {
            if (val >= 0)
            {
                if (!progressBar.Visible)
                {
                    this.CrossThreadControlVisibility(progressBar, true);
                }
                this.CrossThreadProgressUpdate(progressBar, val, max);
            }
            else
            {
                this.CrossThreadProgressUpdate(progressBar, 0, 1);
                this.CrossThreadControlVisibility(progressBar, false);
            }
        }

        void _backendInstance_OnMessage(object sender, Backend.MessageEventArgs e)
        {
            MessageBoxIcon msgIcon = (MessageBoxIcon)e.MessageType;
            string msgTitle = (!String.IsNullOrEmpty(e.MessageTitle)) ?
                e.MessageTitle : Application.ProductName;
            string msgText = (!String.IsNullOrEmpty(e.Message)) ?
                e.Message : "No message text was specified by the caller.";
            this.CrossThreadMessageBox(msgText, msgTitle, msgIcon);
        }

#if DEBUG
        bool _backendInstance_OnBeforeMergeFolders()
        {
            DialogResult result =
                MessageBox.Show("Do you want to merge folders ?\n\nThis process"
                + " is irreversible and will permanently modify your source.",
                "Merge Folders ?", MessageBoxButtons.YesNo, MessageBoxIcon.Question,
                MessageBoxDefaultButton.Button2);
            return result == DialogResult.Yes;
        }

        void _backendInstance_OnDebuggingMessage(string message, string title)
        {
            MessageBox.Show(message, title, MessageBoxButtons.OK,
                MessageBoxIcon.Information);
        }
#endif
        #endregion

        #region Cross-thread UI manipulation helpers
        delegate void MessageBoxDelegate(string msg, string title,
            MessageBoxIcon icon);
        delegate void ProgressBarDelegate(ProgressBar progressBar, int val, int max);
        delegate void ControlEnablePropertyDelegate(Control control, bool enabled);
        delegate void ControlTextDelegate(Control control, string text);

        void CrossThreadMessageBox(string message, string title, MessageBoxIcon icon)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(new MessageBoxDelegate(CrossThreadMessageBox),
                    message, title, icon);
            }
            else
            {
                MessageBox.Show(this, message, title, MessageBoxButtons.OK, icon);
            }
        }

        void CrossThreadProgressUpdate(ProgressBar progressBar, int val, int max)
        {
            if (progressBar.InvokeRequired)
            {
                // Should I use BeginInvoke here ? Invoke is pretty slow :-(
                progressBar.Invoke(new ProgressBarDelegate(CrossThreadProgressUpdate),
                    progressBar, val, max);
            }
            else
            {
                progressBar.Maximum = max;
                progressBar.Value = val;
            }
        }

        void CrossThreadControlVisibility(Control control, bool visible)
        {
            if (control.InvokeRequired)
            {
                control.Invoke(new ControlEnablePropertyDelegate(
                    this.CrossThreadControlVisibility), control, visible);
            }
            else
            {
                control.Visible = visible;
            }
        }

        void CrossThreadControlEnabled(Control control, bool enabled)
        {
            if (control.InvokeRequired)
            {
                control.Invoke(new ControlEnablePropertyDelegate(
                    this.CrossThreadControlEnabled), control, enabled);
            }
            else
            {
                control.Enabled = enabled;
            }
        }

        void CrossThreadControlText(Control control, string text)
        {
            if (control.InvokeRequired)
            {
                control.Invoke(new ControlTextDelegate(
                    CrossThreadControlText), control, text);
            }
            else
            {
                control.Text = text;
            }
        }

        void CrossThreadShowDialog(Form dialog)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(new Action<Form>(CrossThreadShowDialog), dialog);
            }
            else
            {
                dialog.ShowDialog(this);
            }
        }
        #endregion
    }
}