using System;
using System.Text;
using System.Collections.Generic;
using System.IO;
using Epsilon.IO;
using Epsilon.DebugServices;
using System.Windows.Forms;
using System.Threading;
using Epsilon.Slipstreamers;
using System.Diagnostics;

namespace Epsilon.WMP11Slipstreamer
{
    partial class MainForm
    {
        Backend _backend;
        bool _workerInCriticalOperation;

        void WorkerMethod(object workerParam)
        {
            BackendParams paramsBackend = (BackendParams)workerParam;

            try
            {
                this._backend = new Backend(paramsBackend);

                // Handle the events generated by the backend
                this._backend.AnnounceOperation
                    += new Action<string>(_backend_OnAnnounceOperation);
                this._backend.Message
                    += delegate(object eventSender, Backend.MessageEventArgs args)
                    {
                        MessageBox.Show(args.Message, args.MessageTitle,
                            MessageBoxButtons.OK, (MessageBoxIcon)args.MessageType);
                    };
                this._backend.UpdateCurrentProgress
                    += new Backend.ProgressEventDelegate(
                    this._backend_OnCurrentProgressUpdate);
                this._backend.UpdateGlobalProgress
                    += new Backend.ProgressEventDelegate(
                    this._backend_OnGlobalProgressUpdate);
                this._backend.EnterCriticalOperation
                    += delegate(SlipstreamerBase slip)
                    { this._workerInCriticalOperation = true; };
                this._backend.ExitCriticalOperation
                    += delegate(SlipstreamerBase slip) 
                    { this._workerInCriticalOperation = false; };

                // Helps in debugging
                this._backend.Checkpoint
                    += new Predicate<string>(this.Backend_Checkpoint);

                // Start the backend's operations
                this._backend.Slipstream();

                // If it made it up to here with no exceptions, then it succeeded.
                paramsBackend.Result = BackendResult.Success;
            }
            catch (Backend.Exceptions.SlipstreamerAbortedException)
            {
                try
                {
                    FileSystem.Delete(this._backend.WorkingDirectory);
                }
                catch (Exception unexpected)
                {
                    this.CrossThreadMessageBox(
                        "An error occurred while deleting the temporary folder."
                        + Environment.NewLine
                        + "Please delete the following folder manually"
                        + " to restore your source to its previous condition:"
                        + Environment.NewLine + Environment.NewLine
                        + this._backend.WorkingDirectory
                        + Environment.NewLine + Environment.NewLine
                        + "Error details: " + unexpected.Message, 
                        "Error while cancelling", MessageBoxIcon.Error);
                }
                finally
                {
                    paramsBackend.Result = BackendResult.Cancelled;
                }
            }
            catch (Backend.Exceptions.IntegrationException ex)
            {
                HelperConsole.ErrorWriteLine("Integration Error:");
                HelperConsole.ErrorWriteLine(ex.ToString());

                if (ex.InnerException != null)
                {
                    this.ShowUnhandledExceptionForm(paramsBackend, ex.InnerException);
                }
                else
                {
                    this.CrossThreadMessageBox("An error occurred during integration:"
                        + Environment.NewLine
                        + Environment.NewLine
                        + ex.FullMessage,
                        "Integration Error", MessageBoxIcon.Error
                    );

                    paramsBackend.Result = BackendResult.Error;

                }
            }
            catch (Exception ex)
            {
                HelperConsole.ErrorWriteLine("Unhandled Error:");
                HelperConsole.ErrorWriteLine(ex.ToString());

                ShowUnhandledExceptionForm(paramsBackend, ex);
            }
            finally
            {
                // Return to first state
                this.CrossThreadControlVisibility(this.uxProgressBarCurrent, false);
                this.CrossThreadProgressUpdate(this.uxProgressBarOverall, 0, 1);
                this.CrossThreadControlEnabled(this.uxButtonCancel, true);
                this.CrossThreadControlText(this.uxLabelOperation, String.Empty);
            }
        }

        private void ShowUnhandledExceptionForm(BackendParams paramsBackend, Exception ex)
        {
            try
            {
                this.CrossThreadShowDialog(new ErrorForm(ex,
                    this._workerInCriticalOperation,
                    this._backend.WorkingDirectory,
                    this._backend.OsInfo.ToString(),
                    this.uxTextBoxHotfixLine.Text));
            }
            finally
            {
                paramsBackend.Result = BackendResult.UnhandledException;
            }
        }

        #region Backend event handlers
        void _backend_OnAnnounceOperation(string announceString)
        {
            this.CrossThreadControlText(this.uxLabelOperation, announceString);
        }

        void _backend_OnCurrentProgressUpdate(int val, int max)
        {
            this.CrossThreadProgressBarHandler(this.uxProgressBarCurrent, val, max);
        }

        void _backend_OnGlobalProgressUpdate(int val, int max)
        {
            this.CrossThreadProgressBarHandler(this.uxProgressBarOverall, val, max);
        }

        void CrossThreadProgressBarHandler(ProgressBar progressBar, int val, int max)
        {
            if (val >= 0)
            {
                if (!progressBar.Visible)
                {
                    this.CrossThreadControlVisibility(progressBar, true);
                }
                this.CrossThreadProgressUpdate(progressBar, val, max);
            }
            else
            {
                this.CrossThreadProgressUpdate(progressBar, 0, 1);
                this.CrossThreadControlVisibility(progressBar, false);
            }
        }

#if DEBUG
        bool Backend_Checkpoint(string message)
        {
            DialogResult result =
                MessageBox.Show(message, "Checkpoint",
                MessageBoxButtons.YesNoCancel, MessageBoxIcon.Question,
                MessageBoxDefaultButton.Button2);

            switch (result)
            {
                case DialogResult.Yes: return true;
                case DialogResult.No: return false;
                case DialogResult.Cancel: this._backend.Abort(); break;
            }

            return false;
        }
#endif
        #endregion

        #region Cross-thread UI manipulation helpers
        delegate void MessageBoxDelegate(string msg, string title,
            MessageBoxIcon icon);
        delegate void ProgressBarDelegate(ProgressBar progressBar, int val, int max);
        delegate void ControlEnablePropertyDelegate(Control control, bool enabled);
        delegate void ControlTextDelegate(Control control, string text);

        void CrossThreadMessageBox(string message, string title, MessageBoxIcon icon)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(new MessageBoxDelegate(CrossThreadMessageBox),
                    message, title, icon);
            }
            else
            {
                MessageBox.Show(this, message, title, MessageBoxButtons.OK, icon);
            }
        }

        void CrossThreadProgressUpdate(ProgressBar progressBar, int val, int max)
        {
            if (progressBar.InvokeRequired)
            {
                // Should I use BeginInvoke here ? Invoke is pretty slow :-(
                progressBar.Invoke(new ProgressBarDelegate(CrossThreadProgressUpdate),
                    progressBar, val, max);
            }
            else
            {
                progressBar.Maximum = max;
                progressBar.Value = val;
            }
        }

        void CrossThreadControlVisibility(Control control, bool visible)
        {
            if (control.InvokeRequired)
            {
                control.Invoke(new ControlEnablePropertyDelegate(
                    this.CrossThreadControlVisibility), control, visible);
            }
            else
            {
                control.Visible = visible;
            }
        }

        void CrossThreadControlEnabled(Control control, bool enabled)
        {
            if (control.InvokeRequired)
            {
                control.Invoke(new ControlEnablePropertyDelegate(
                    this.CrossThreadControlEnabled), control, enabled);
            }
            else
            {
                control.Enabled = enabled;
            }
        }

        void CrossThreadControlText(Control control, string text)
        {
            if (control.InvokeRequired)
            {
                control.Invoke(new ControlTextDelegate(
                    CrossThreadControlText), control, text);
            }
            else
            {
                control.Text = text;
            }
        }

        void CrossThreadShowDialog(Form dialog)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(new Action<Form>(CrossThreadShowDialog), dialog);
            }
            else
            {
                dialog.ShowDialog(this);
            }
        }
        #endregion
    }
}