using System;
using System.Text;
using System.Collections.Generic;
using System.IO;
using Epsilon.IO;
using Epsilon.DebugServices;
using System.Windows.Forms;
using System.Threading;
using Epsilon.Slipstreamers;
using System.Diagnostics;
using Epsilon.WMP11Slipstreamer.Localization;

namespace Epsilon.WMP11Slipstreamer
{
    partial class MainForm
    {
        Backend _backend;

        void WorkerMethod(object workerParam)
        {
            BackendParams paramsBackend = (BackendParams)workerParam;

            try
            {
                this._backend = new Backend(paramsBackend);

                // Handle the events generated by the backend
                this._backend.AnnounceOperation
                    += new Action<string>(_backend_OnAnnounceOperation);
                this._backend.Message
                    += delegate(object eventSender, Backend.MessageEventArgs args)
                    {
                        MessageBox.Show(args.Message, args.MessageTitle,
                            MessageBoxButtons.OK, (MessageBoxIcon)args.MessageType);
                    };
                this._backend.UpdateCurrentProgress
                    += new Backend.ProgressEventDelegate(
                    this._backend_OnCurrentProgressUpdate);
                this._backend.UpdateGlobalProgress
                    += new Backend.ProgressEventDelegate(
                    this._backend_OnGlobalProgressUpdate);
                this._backend.BeginCriticalOperation
                    += delegate(SlipstreamerBase slip)
                    {
                        this.CrossThreadControlEnabled(this.uxButtonCancel, false);
                    };
                this._backend.ExitCriticalOperation
                    += delegate(SlipstreamerBase slip) 
                    {
                        this.CrossThreadControlEnabled(this.uxButtonCancel, true);
                    };

#if DEBUG
                // Helps in debugging
                this._backend.Checkpoint
                    += new Predicate<string>(delegate(string message)
                        {
                            DialogResult result =
                                MessageBox.Show(message, "Checkpoint",
                                MessageBoxButtons.YesNoCancel, 
                                MessageBoxIcon.Question,
                                MessageBoxDefaultButton.Button2);

                            switch (result)
                            {
                                case DialogResult.Yes: return true;
                                case DialogResult.No: return false;
                                case DialogResult.Cancel: 
                                    this._backend.Abort(); break;
                            }
                            return false;
                        });
#endif

                // Start the backend's operations
                this._backend.Slipstream();
            }
            catch (IntegrationException ex)
            {
                HelperConsole.ErrorWriteLine("Integration Error:");
                HelperConsole.ErrorWriteLine(ex.ToString());

                if (ex.InnerException != null)
                {
                    this.ShowUnhandledExceptionForm(
                        paramsBackend, 
                        ex.InnerException);
                }
                else
                {
                    this.CrossThreadMessageBox(
                        Msg.dlgIntegError_Header
                        + Environment.NewLine
                        + Environment.NewLine
                        + ex.FullMessage,
                        Msg.dlgIntegError_Title, MessageBoxIcon.Error
                    );

                    if (Directory.Exists(this._backend.WorkingDirectory))
                        this.ShowCleanupFailedBox();
                }
            }
            catch (Exception ex)
            {
                HelperConsole.ErrorWriteLine("Unhandled Error:");
                HelperConsole.ErrorWriteLine(ex.ToString());

                this.ShowUnhandledExceptionForm(paramsBackend, ex);
            }
            finally
            {
                if (paramsBackend.Status == SlipstreamerStatus.Cancelled
                    && Directory.Exists(this._backend.WorkingDirectory))
                    this.ShowCleanupFailedBox();

                // Return to first state
                this.CrossThreadControlVisibility(this.uxProgressBarCurrent, false);
                this.CrossThreadProgressUpdate(this.uxProgressBarOverall, 0, 1);
                this.CrossThreadControlEnabled(this.uxButtonCancel, true);
                this.CrossThreadControlText(this.uxLabelOperation, String.Empty);
            }
        }

        void ShowCleanupFailedBox()
        {
            this.CrossThreadMessageBox(Msg.dlgError_ErrorDuringCleanup
                + Environment.NewLine
                + Msg.dlgError_DeleteTempDirManually
                + Environment.NewLine + Environment.NewLine
                + this._backend.WorkingDirectory,
                Msg.dlgCleanupFailed_Title, MessageBoxIcon.Error);
        }

        void ShowUnhandledExceptionForm(BackendParams paramsBackend, Exception ex)
        {
            this.CrossThreadShowDialog(new ErrorForm(ex,
                paramsBackend.Status == SlipstreamerStatus.CriticalError,
                (this._backend != null) ? this._backend.WorkingDirectory : null,
                (this._backend != null) ? this._backend.OsInfo.ToString() : null,
                this.uxTextBoxHotfixLine.Text));
        }

        #region Backend event handlers
        void _backend_OnAnnounceOperation(string announceString)
        {
            this.CrossThreadControlText(this.uxLabelOperation, announceString);
        }

        void _backend_OnCurrentProgressUpdate(int val, int max)
        {
            this.CrossThreadProgressBarHandler(this.uxProgressBarCurrent, val, max);
        }

        void _backend_OnGlobalProgressUpdate(int val, int max)
        {
            this.CrossThreadProgressBarHandler(this.uxProgressBarOverall, val, max);
        }

        void CrossThreadProgressBarHandler(ProgressBar progressBar, int val, int max)
        {
            if (val >= 0)
            {
                if (!progressBar.Visible)
                {
                    this.CrossThreadControlVisibility(progressBar, true);
                }
                this.CrossThreadProgressUpdate(progressBar, val, max);
            }
            else
            {
                this.CrossThreadProgressUpdate(progressBar, 0, 1);
                this.CrossThreadControlVisibility(progressBar, false);
            }
        }
        #endregion

        #region Cross-thread UI manipulation helpers
        delegate void MessageBoxDelegate(string msg, string title,
            MessageBoxIcon icon);
        delegate void ProgressBarDelegate(ProgressBar progressBar, int val, int max);
        delegate void ControlEnablePropertyDelegate(Control control, bool enabled);
        delegate void ControlTextDelegate(Control control, string text);

        void CrossThreadMessageBox(string message, string title, MessageBoxIcon icon)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(new MessageBoxDelegate(CrossThreadMessageBox),
                    message, title, icon);
            }
            else
            {
                MessageBox.Show(this, message, title, MessageBoxButtons.OK, icon);
            }
        }

        void CrossThreadProgressUpdate(ProgressBar progressBar, int val, int max)
        {
            if (progressBar.InvokeRequired)
            {
                // Should I use BeginInvoke here ? Invoke is pretty slow :-(
                progressBar.Invoke(new ProgressBarDelegate(CrossThreadProgressUpdate),
                    progressBar, val, max);
            }
            else
            {
                progressBar.Maximum = max;
                progressBar.Value = val;
            }
        }

        void CrossThreadControlVisibility(Control control, bool visible)
        {
            if (control.InvokeRequired)
            {
                control.Invoke(new ControlEnablePropertyDelegate(
                    this.CrossThreadControlVisibility), control, visible);
            }
            else
            {
                control.Visible = visible;
            }
        }

        void CrossThreadControlEnabled(Control control, bool enabled)
        {
            if (control.InvokeRequired)
            {
                control.Invoke(new ControlEnablePropertyDelegate(
                    this.CrossThreadControlEnabled), control, enabled);
            }
            else
            {
                control.Enabled = enabled;
            }
        }

        void CrossThreadControlText(Control control, string text)
        {
            if (control.InvokeRequired)
            {
                control.Invoke(new ControlTextDelegate(
                    CrossThreadControlText), control, text);
            }
            else
            {
                control.Text = text;
            }
        }

        void CrossThreadShowDialog(Form dialog)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(new Action<Form>(CrossThreadShowDialog), dialog);
            }
            else
            {
                dialog.ShowDialog(this);
            }
        }
        #endregion
    }
}