using System;
using System.Diagnostics;
using System.IO;
using System.Windows.Forms;
using Epsilon.DebugServices;
using Epsilon.Slipstreamers;
using Epsilon.WMP11Slipstreamer.Localization;

namespace Epsilon.WMP11Slipstreamer
{
    partial class MainForm
    {
        Backend _backend;

        void WorkerMethod(object workerParam)
        {
            var paramsBackend = (BackendParams)workerParam;

            try
            {
                this._backend = new Backend(paramsBackend);

                // Handle the events generated by the backend
                this._backend.AnnounceOperation
                    += this._backend_OnAnnounceOperation;
                this._backend.Message
                    += (eventSender, args) => MessageBox.Show(
                        args.Message,
                        args.MessageTitle,
                        MessageBoxButtons.OK,
                        (MessageBoxIcon)args.MessageType);
                this._backend.UpdateCurrentProgress
                    += this._backend_OnCurrentProgressUpdate;
                this._backend.UpdateGlobalProgress
                    += this._backend_OnGlobalProgressUpdate;
                this._backend.BeginCriticalOperation
                    += delegate { this.CrossThreadControlEnabled(this.uxButtonCancel, false); };
                this._backend.ExitCriticalOperation
                    += delegate { this.CrossThreadControlEnabled(this.uxButtonCancel, true); };


                this.HandleCheckpointEvent();

                // Start the backend's operations
                this._backend.Slipstream();
            }
            catch (IntegrationException ex)
            {
                HelperConsole.ErrorWriteLine("Integration Error:");
                HelperConsole.ErrorWriteLine(ex.ToString());

                if (ex.InnerException != null)
                {
                    this.ShowUnhandledExceptionForm(
                        paramsBackend,
                        ex.InnerException);
                }
                else
                {
                    this.CrossThreadMessageBox(
                        Msg.dlgIntegError_Header
                        + Environment.NewLine
                        + Environment.NewLine
                        + ex.FullMessage,
                        Msg.dlgIntegError_Title,
                        MessageBoxIcon.Error
                        );

                    if (Directory.Exists(this._backend.WorkingDirectory))
                        this.ShowCleanupFailedBox();
                }
            }
            catch (Exception ex)
            {
                HelperConsole.ErrorWriteLine("Unhandled Error:");
                HelperConsole.ErrorWriteLine(ex.ToString());

                this.ShowUnhandledExceptionForm(paramsBackend, ex);
            }
            finally
            {
                if (paramsBackend.Status == SlipstreamerStatus.Cancelled
                    && Directory.Exists(this._backend.WorkingDirectory))
                    this.ShowCleanupFailedBox();

                // Return to first state
                this.CrossThreadControlVisibility(this.uxProgressBarCurrent, false);
                this.CrossThreadProgressUpdate(this.uxProgressBarOverall, 0, 1);
                this.CrossThreadControlEnabled(this.uxButtonCancel, true);
                this.CrossThreadControlText(this.uxLabelOperation, String.Empty);
            }
        }

        [Conditional("DEBUG")]
        void HandleCheckpointEvent()
        {
            // Helps in debugging
            this._backend.Checkpoint
                += delegate(string message)
                   {
                       DialogResult result =
                           MessageBox.Show(
                               message,
                               "Checkpoint",
                               MessageBoxButtons.YesNoCancel,
                               MessageBoxIcon.Question,
                               MessageBoxDefaultButton.Button2);

                       switch (result)
                       {
                           case DialogResult.Yes:
                               return true;
                           case DialogResult.No:
                               return false;
                           case DialogResult.Cancel:
                               this._backend.Abort();
                               break;
                       }
                       return false;
                   };
        }

        void ShowCleanupFailedBox()
        {
            this.CrossThreadMessageBox(
                Msg.dlgError_ErrorDuringCleanup
                + Environment.NewLine
                + Msg.dlgError_DeleteTempDirManually
                + Environment.NewLine + Environment.NewLine
                + this._backend.WorkingDirectory,
                Msg.dlgCleanupFailed_Title,
                MessageBoxIcon.Error);
        }

        void ShowUnhandledExceptionForm(BackendParams paramsBackend, Exception ex)
        {
            this.CrossThreadShowDialog(
                new ErrorForm(
                    ex,
                    paramsBackend.Status == SlipstreamerStatus.CriticalError,
                    (this._backend != null) ? this._backend.WorkingDirectory : null,
                    (this._backend != null) ? this._backend.OsInfo.ToString() : null,
                    this.uxTextBoxHotfixLine.Text));
        }

        #region Backend event handlers
        void _backend_OnAnnounceOperation(string announceString)
        {
            this.CrossThreadControlText(this.uxLabelOperation, announceString);
        }

        void _backend_OnCurrentProgressUpdate(int val, int max)
        {
            this.CrossThreadProgressBarHandler(this.uxProgressBarCurrent, val, max);
        }

        void _backend_OnGlobalProgressUpdate(int val, int max)
        {
            this.CrossThreadProgressBarHandler(this.uxProgressBarOverall, val, max);
        }

        void CrossThreadProgressBarHandler(ProgressBar progressBar, int val, int max)
        {
            if (val >= 0)
            {
                if (!progressBar.Visible)
                {
                    this.CrossThreadControlVisibility(progressBar, true);
                }
                this.CrossThreadProgressUpdate(progressBar, val, max);
            }
            else
            {
                this.CrossThreadProgressUpdate(progressBar, 0, 1);
                this.CrossThreadControlVisibility(progressBar, false);
            }
        }
        #endregion

        #region Cross-thread UI manipulation helpers
        void CrossThreadMessageBox(string message, string title, MessageBoxIcon icon)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(
                    new MessageBoxDelegate(this.CrossThreadMessageBox),
                    message,
                    title,
                    icon);
            }
            else
            {
                MessageBox.Show(this, message, title, MessageBoxButtons.OK, icon);
            }
        }

        void CrossThreadProgressUpdate(ProgressBar progressBar, int val, int max)
        {
            if (progressBar.InvokeRequired)
            {
                // Should I use BeginInvoke here ? Invoke is pretty slow :-(
                progressBar.Invoke(
                    new ProgressBarDelegate(this.CrossThreadProgressUpdate),
                    progressBar,
                    val,
                    max);
            }
            else
            {
                progressBar.Maximum = max;
                progressBar.Value = val;
            }
        }

        void CrossThreadControlVisibility(Control control, bool visible)
        {
            if (control.InvokeRequired)
            {
                control.Invoke(
                    new ControlEnablePropertyDelegate(
                        this.CrossThreadControlVisibility),
                    control,
                    visible);
            }
            else
            {
                control.Visible = visible;
            }
        }

        void CrossThreadControlEnabled(Control control, bool enabled)
        {
            if (control.InvokeRequired)
            {
                control.Invoke(
                    new ControlEnablePropertyDelegate(
                        this.CrossThreadControlEnabled),
                    control,
                    enabled);
            }
            else
            {
                control.Enabled = enabled;
            }
        }

        void CrossThreadControlText(Control control, string text)
        {
            if (control.InvokeRequired)
            {
                control.Invoke(
                    new ControlTextDelegate(
                        this.CrossThreadControlText),
                    control,
                    text);
            }
            else
            {
                control.Text = text;
            }
        }

        void CrossThreadShowDialog(Form dialog)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(new Action<Form>(this.CrossThreadShowDialog), dialog);
            }
            else
            {
                dialog.ShowDialog(this);
            }
        }

        #region Nested type: ControlEnablePropertyDelegate
        delegate void ControlEnablePropertyDelegate(Control control, bool enabled);
        #endregion

        #region Nested type: ControlTextDelegate
        delegate void ControlTextDelegate(Control control, string text);
        #endregion

        #region Nested type: MessageBoxDelegate
        delegate void MessageBoxDelegate(string msg, string title,
                                         MessageBoxIcon icon);
        #endregion

        #region Nested type: ProgressBarDelegate
        delegate void ProgressBarDelegate(ProgressBar progressBar, int val, int max);
        #endregion

        #endregion
    }
}